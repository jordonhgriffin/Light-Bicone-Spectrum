<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Light Bicone Spectrum | The Geometry of Perception</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&family=Inter:wght@300;400&display=swap" rel="stylesheet">
    <script type="importmap">
        {
          "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
          }
        }
    </script>
    <style>
        :root {
            --bg-color: #050505;
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.7);
            --accent-color: #3d5afe;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-primary);
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        #container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
            padding: 2rem;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        h1 {
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 2.5rem;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
            background: linear-gradient(to right, #fff, rgba(255, 255, 255, 0.5));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .legend {
            position: absolute;
            top: 50%;
            right: 2rem;
            transform: translateY(-50%);
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            padding: 1.5rem;
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            max-width: 280px;
            pointer-events: auto;
            z-index: 100;
        }

        .legend .section {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .legend .section-label {
            margin-bottom: 0.25rem;
            opacity: 0.8;
        }

        .legend-item {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .label {
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .value {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .bottom-bar {
            display: flex;
            align-items: flex-end;
            gap: 1.5rem;
            pointer-events: none;
            width: 100%;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            pointer-events: auto;
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            padding: 1.5rem;
            border-radius: 12px;
            width: 300px;
        }

        .playback-controls {
            display: flex;
            gap: 0.5rem;
        }

        .section-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
            margin-bottom: -0.5rem;
        }

        .preset-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
        }

        .preset-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }

        .preset-btn:not(.color-btn) {
            grid-column: span 2;
        }

        .color-btn {
            width: 40px;
            height: 40px;
            padding: 0;
        }

        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .preset-btn.active {
            background: rgba(255, 255, 255, 0.4);
            border-color: var(--text-primary);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }

        button:not(.preset-btn) {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 0.6rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            transition: all 0.3s ease;
            flex: 1;
        }

        button:not(.preset-btn):hover {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .hint {
            font-size: 0.8rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            padding: 1.5rem;
            width: 320px;
            pointer-events: auto;
        }

        .inspector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .inspector-header h3 {
            font-family: 'Outfit', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
        }

        .badge {
            font-size: 0.7rem;
            padding: 0.25rem 0.6rem;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
        }

        .badge.visible { background: rgba(76, 175, 80, 0.2); color: #81c784; }
        .badge.non-visible { background: rgba(255, 152, 0, 0.2); color: #ffb74d; }

        .inspector-content {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .data-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        .data-value {
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
        }

        .color-preview {
            margin-top: 1.5rem;
            height: 48px;
            border-radius: 8px;
            background: #000;
            border: 1px solid var(--glass-border);
            transition: background-color 0.2s ease;
        }
        /* Version Display */
        #version-display {
            position: fixed;
            bottom: 10px;
            right: 15px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 0.9rem;
            font-weight: 500;
            pointer-events: auto;
            z-index: 9999;
        }

        #version-display a {
            color: inherit;
            text-decoration: none;
            font-weight: 700;
            transition: color 0.2s ease;
        }

        .mobile-toggle {
            display: none;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid var(--glass-border);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            backdrop-filter: blur(10px);
            white-space: nowrap;
        }

        .toggle-group {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
        }

        /* Mobile Optimizations */
        @media (max-width: 768px) {
            #ui {
                padding: 1rem;
                display: block; /* Switch to block to control positioning manually or use grid */
            }

            h1 {
                font-size: 1.5rem;
                margin-bottom: 0.25rem;
                width: 100%;
            }

            .subtitle {
                font-size: 0.8rem;
                display: block;
                margin-bottom: 0.5rem;
            }

            .mobile-toggle {
                display: block;
            }

            .legend {
                display: none;
                top: 1rem;
                right: 1rem;
                transform: none;
                max-width: 200px;
                padding: 1rem;
                gap: 0.75rem;
                font-size: 0.75rem;
                z-index: 1000;
            }

            .legend .label { font-size: 0.75rem; }
            .legend .value { font-size: 0.7rem; }
            .legend .section { gap: 0.4rem; }

            .legend.active {
                display: flex;
            }

            .bottom-bar {
                position: absolute;
                bottom: 40px;
                left: 1rem;
                right: 1rem;
                width: calc(100% - 2rem);
                display: block;
                pointer-events: none;
            }

            .controls {
                display: none; /* Hidden by default on mobile */
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 320px;
                z-index: 2000;
                pointer-events: auto;
                box-shadow: 0 0 50px rgba(0,0,0,0.5);
            }

            .controls.active {
                display: flex;
            }

            .glass-panel {
                width: 100%;
                pointer-events: auto;
                padding: 1rem;
            }

            #version-display {
                font-size: 0.7rem;
                bottom: 5px;
                right: 50%;
                transform: translateX(50%);
                width: 100%;
                text-align: center;
                background: none;
            }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="ui">
        <h1>Light Bicone Spectrum</h1>
        <p class="subtitle">A Relativistic Mapping of Perception</p>

        <div class="toggle-group">
            <button id="legendToggle" class="mobile-toggle">Show Legend</button>
            <button id="controlsToggle" class="mobile-toggle">Show Presets</button>
        </div>

        <div class="legend" id="mainLegend">
            <div class="section">
                <p class="section-label">Spacetime Mapping</p>
                <div class="legend-item">
                    <span class="label">Vertical Axis (Y)</span>
                    <span class="value">Brightness</span>
                </div>
                <div class="legend-item">
                    <span class="label">Radial Distance (R)</span>
                    <span class="value">Saturation / Intensity</span>
                </div>
                <div class="legend-item">
                    <span class="label">Rotation (Î¸)</span>
                    <span class="value">Hue / Variety</span>
                </div>
            </div>

            <div class="section">
                <p class="section-label">Spectral Limits</p>
                <div class="legend-item">
                    <span class="label">Future / Approach (UV)</span>
                    <span class="value">Higher Energy / White</span>
                </div>
                <div class="legend-item">
                    <span class="label">Present (Visible)</span>
                    <span class="value">Max Saturation / Coordination</span>
                </div>
                <div class="legend-item">
                    <span class="label">Past / Recession (IR)</span>
                    <span class="value">Lower Energy / Black</span>
                </div>
            </div>
        </div>

        <div class="bottom-bar">
            <div class="controls" id="mainControls">
                <div class="playback-controls">
                    <button id="toggleRotation">Pause Rotation</button>
                    <button id="resetRotation">Reset View</button>
                </div>

                <p class="section-label">Jump to Spectral Point</p>
                <div class="preset-grid">
                    <button class="preset-btn" data-type="apex" data-value="top" title="UV / Future">Top Apex</button>
                    <button class="preset-btn" data-type="apex" data-value="bottom" title="IR / Past">Bottom Apex</button>
                    <button class="preset-btn color-btn" data-type="color" data-value="red" style="background: #ff0000;"></button>
                    <button class="preset-btn color-btn" data-type="color" data-value="yellow" style="background: #ffff00;"></button>
                    <button class="preset-btn color-btn" data-type="color" data-value="green" style="background: #00ff00;"></button>
                    <button class="preset-btn color-btn" data-type="color" data-value="cyan" style="background: #00ffff;"></button>
                    <button class="preset-btn color-btn" data-type="color" data-value="blue" style="background: #0000ff;"></button>
                    <button class="preset-btn color-btn" data-type="color" data-value="magenta" style="background: #ff00ff;"></button>
                </div>

                <p class="hint">Click and drag to rotate. Scroll to zoom.</p>
            </div>

            <!-- Inspector Panel -->
            <div id="inspector" class="glass-panel">
                <div class="inspector-header">
                    <h3>Point Inspector</h3>
                    <span id="visibilityBadge" class="badge">Hover to inspect</span>
                </div>
                <div class="inspector-content">
                    <div class="data-row">
                        <span class="data-label">HEX</span>
                        <span id="hexValue" class="data-value">#------</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">RGB</span>
                        <span id="rgbValue" class="data-value">---, ---, ---</span>
                    </div>
                    <div class="data-row">
                        <span class="data-label">Wavelength</span>
                        <span id="nmValue" class="data-value">--- nm</span>
                    </div>
                </div>
                <div class="color-preview" id="colorPreview"></div>
            </div>
        </div>
    </div>

    <!-- Version Display -->
    <div id="version-display">Version 26.2.2 &nbsp;|&nbsp; Made by <a href="https://jordonhgriffin.github.io" target="_blank">JHG</a></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene Setup
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        camera.position.set(4, 3, 4);
        controls.update();

        // Custom Shader Material
        const biconeShader = {
            uniforms: {
                time: { value: 0 },
            },
            vertexShader: `
                varying vec3 vPosition;
                varying vec2 vUv;
                void main() {
                    vPosition = position;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vPosition;
                varying vec2 vUv;

                // Helper to convert HSL to RGB
                vec3 hsl2rgb(vec3 c) {
                    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
                    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
                }

                void main() {
                    float angle = atan(vPosition.z, vPosition.x);
                    float hue = (angle / 6.28318) + 0.5;

                    // Normalize y coordinate (-1 to 1)
                    float y = vPosition.y / 2.0;

                    vec3 color;
                    float saturation = 0.9;

                    if (y >= 0.0) {
                        float lightness = mix(0.5, 1.0, y);
                        color = hsl2rgb(vec3(hue, saturation, lightness));
                    } else {
                        float lightness = mix(0.5, 0.0, -y);
                        color = hsl2rgb(vec3(hue, saturation, lightness));
                    }

                    float edge = 1.0 - abs(vPosition.y / 2.0);
                    color += vec3(0.1, 0.1, 0.2) * pow(edge, 3.0);

                    gl_FragColor = vec4(color, 0.9);
                }
            `
        };

        const material = new THREE.ShaderMaterial({
            uniforms: biconeShader.uniforms,
            vertexShader: biconeShader.vertexShader,
            fragmentShader: biconeShader.fragmentShader,
            transparent: true,
            side: THREE.DoubleSide
        });

        // Bicone Geometry
        const radius = 2;
        const height = 2;
        const segments = 128;

        const topConeGeo = new THREE.ConeGeometry(radius, height, segments, 1, true);
        topConeGeo.translate(0, height / 2, 0);

        const bottomConeGeo = new THREE.ConeGeometry(radius, height, segments, 1, true);
        bottomConeGeo.rotateX(Math.PI);
        bottomConeGeo.translate(0, -height / 2, 0);

        const topCone = new THREE.Mesh(topConeGeo, material);
        const bottomCone = new THREE.Mesh(bottomConeGeo, material);

        const biconeGroup = new THREE.Group();
        biconeGroup.add(topCone);
        biconeGroup.add(bottomCone);
        scene.add(biconeGroup);

        // Selection Indicator
        const indicatorGeo = new THREE.SphereGeometry(0.1, 16, 16);
        const indicatorMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const selectionIndicator = new THREE.Mesh(indicatorGeo, indicatorMat);
        selectionIndicator.visible = false;
        scene.add(selectionIndicator);

        // Glowing Spectrum Ring
        const ringRadius = 2.01;
        const torusGeo = new THREE.TorusGeometry(ringRadius, 0.02, 16, 128);
        torusGeo.rotateX(Math.PI / 2);

        const torusMaterial = new THREE.ShaderMaterial({
            vertexShader: `
                varying vec3 vPosition;
                void main() {
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                varying vec3 vPosition;
                vec3 hsl2rgb(vec3 c) {
                    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);
                    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
                }
                void main() {
                    float angle = atan(vPosition.z, vPosition.x);
                    float hue = (angle / 6.28318) + 0.5;
                    gl_FragColor = vec4(hsl2rgb(vec3(hue, 1.0, 0.5)), 1.0);
                }
            `,
            side: THREE.DoubleSide
        });
        const spectrumRing = new THREE.Mesh(torusGeo, torusMaterial);
        biconeGroup.add(spectrumRing);

        // Axis indicators
        const createAxis = (dir, color, length = 3) => {
            const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0, 0, 0), length, color, 0.2, 0.1);
            scene.add(arrow);
            return arrow;
        };

        // Y-Axis: Brightness
        createAxis(new THREE.Vector3(0, 1, 0), 0xffffff, 3.5);
        createAxis(new THREE.Vector3(0, -1, 0), 0x666666, 3.5);

        // X and Z Axes: Hue / Saturation Plane
        createAxis(new THREE.Vector3(1, 0, 0), 0xff3333, 2.5); // "X"
        createAxis(new THREE.Vector3(0, 0, 1), 0x3333ff, 2.5); // "Z"

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const inspector = {
            hex: document.getElementById('hexValue'),
            rgb: document.getElementById('rgbValue'),
            nm: document.getElementById('nmValue'),
            badge: document.getElementById('visibilityBadge'),
            preview: document.getElementById('colorPreview')
        };

        function updateSelectionIndicator(pos) {
            selectionIndicator.position.copy(pos);
            selectionIndicator.visible = true;
            clearTimeout(window.indicatorTimeout);
            window.indicatorTimeout = setTimeout(() => { selectionIndicator.visible = false; }, 3000);
        }

        function getSpectralInfo(point) {
            const angle = Math.atan2(point.z, point.x);
            const hue = (angle / (2 * Math.PI)) + 0.5;
            const yNorm = point.y / 2.0;

            const saturation = 0.9;
            const lightness = 0.5 + (0.5 * yNorm);

            const hslToRgb = (h, s, l) => {
                let r, g, b;
                if (s === 0) r = g = b = l;
                else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    r = hue2rgb(p, q, h + 1 / 3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1 / 3);
                }
                return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            };

            const rgb = hslToRgb(hue, saturation, lightness);
            const hex = `#${rgb.map(x => x.toString(16).padStart(2, '0')).join('')}`;

            let wavelength = "---";
            let status = "Visible";
            let badgeClass = "visible";

            if (yNorm > 0.05) {
                status = "Ultraviolet";
                badgeClass = "non-visible";
                wavelength = `< 380`;
            } else if (yNorm < -0.05) {
                status = "Infrared";
                badgeClass = "non-visible";
                wavelength = `> 750`;
            } else {
                if (hue > 0.83) {
                    wavelength = "Nonspectral";
                } else {
                    const spectralHue = hue / 0.83;
                    const nm = Math.round(750 - (spectralHue * (750 - 380)));
                    wavelength = `${nm}`;
                }
            }
            return { hex, rgb, wavelength, status, badgeClass };
        }

        function updateInspector(info) {
            inspector.hex.textContent = info.hex;
            inspector.rgb.textContent = info.rgb.join(', ');
            inspector.nm.textContent = info.wavelength + (info.wavelength === "Nonspectral" ? "" : " nm");
            inspector.badge.textContent = info.status;
            inspector.badge.className = `badge ${info.badgeClass}`;
            inspector.preview.style.backgroundColor = info.hex;
        }

        let isMouseMoving = false;
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            isMouseMoving = true;
        });

        // Touch support for mobile
        window.addEventListener('touchstart', (event) => {
            if (event.touches.length > 0) {
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        });

        window.addEventListener('touchmove', (event) => {
            if (event.touches.length > 0) {
                mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
            }
        });

        // Mobile Legend Toggle
        const legendToggle = document.getElementById('legendToggle');
        const mainLegend = document.getElementById('mainLegend');

        if (legendToggle && mainLegend) {
            legendToggle.addEventListener('click', () => {
                mainLegend.classList.toggle('active');
                legendToggle.textContent = mainLegend.classList.contains('active') ? 'Hide Legend' : 'Show Legend';
                // Close controls if legend is shown on mobile
                if (window.innerWidth <= 768 && mainLegend.classList.contains('active')) {
                    mainControls.classList.remove('active');
                    controlsToggle.textContent = 'Show Presets';
                }
            });
        }

        // Mobile Controls Toggle
        const controlsToggle = document.getElementById('controlsToggle');
        const mainControls = document.getElementById('mainControls');

        if (controlsToggle && mainControls) {
            controlsToggle.addEventListener('click', () => {
                mainControls.classList.toggle('active');
                controlsToggle.textContent = mainControls.classList.contains('active') ? 'Hide Presets' : 'Show Presets';
                // Close legend if controls are shown on mobile
                if (window.innerWidth <= 768 && mainControls.classList.contains('active')) {
                    mainLegend.classList.remove('active');
                    legendToggle.textContent = 'Show Legend';
                }
            });
        }

        function performRaycast() {
            raycaster.setFromCamera(mouse, camera);
            // Raycast against the group and its children
            const intersects = raycaster.intersectObjects(biconeGroup.children, true);

            if (intersects.length > 0) {
                // Convert world point to local point to account for rotation
                const localPoint = biconeGroup.worldToLocal(intersects[0].point.clone());
                const info = getSpectralInfo(localPoint);
                updateInspector(info);
                selectionIndicator.position.copy(intersects[0].point);
                selectionIndicator.visible = true;
                if (window.indicatorTimeout) {
                    clearTimeout(window.indicatorTimeout);
                    window.indicatorTimeout = null;
                }
            } else {
                // Only start timeout if not already hidden and mouse has moved off
                if (selectionIndicator.visible && !window.indicatorTimeout) {
                    window.indicatorTimeout = setTimeout(() => {
                        selectionIndicator.visible = false;
                        window.indicatorTimeout = null;
                    }, 100);
                }
            }
        }

        // Playback & State
        let isRotating = true;
        const rotationToggle = document.getElementById('toggleRotation');

        rotationToggle.addEventListener('click', () => {
            isRotating = !isRotating;
            rotationToggle.textContent = isRotating ? 'Pause Rotation' : 'Play Rotation';
        });

        const spectralPresets = {
            top: { y: 2, hue: 0 },
            bottom: { y: -2, hue: 0 },
            red: { y: 0, hue: 0 }, // Hue 0.0 in shader is red
            yellow: { y: 0, hue: 0.16 },
            green: { y: 0, hue: 0.33 },
            cyan: { y: 0, hue: 0.5 },
            blue: { y: 0, hue: 0.66 },
            magenta: { y: 0, hue: 0.83 }
        };

        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const val = btn.dataset.value;
                const preset = spectralPresets[val];
                if (!preset) return;

                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                isRotating = false;
                rotationToggle.textContent = 'Play Rotation';

                // Reset bicone rotation to 0 before applying preset to ensure consistent camera view
                biconeGroup.rotation.y = 0;

                let targetPos = new THREE.Vector3();
                if (preset.y > 0) {
                    // Perfectly vertical view from top (Flat Plane effect)
                    targetPos.set(0, 8, 0);
                    controls.target.set(0, preset.y / 2, 0);
                } else if (preset.y < 0) {
                    // Perfectly vertical view from bottom (Flat Plane effect)
                    targetPos.set(0, -8, 0);
                    controls.target.set(0, preset.y / 2, 0);
                } else {
                    // View color on ring (equator)
                    // Shader hue (0-1) maps to angle: angle = (hue - 0.5) * 2 * PI
                    const angle = (preset.hue - 0.5) * (2 * Math.PI);
                    // Camera position: look at the color from a distance
                    targetPos.set(Math.cos(angle) * 5, 0, Math.sin(angle) * 5);
                    controls.target.set(0, 0, 0); // Target the center of the equator
                }

                camera.position.copy(targetPos);
                controls.update();

                const mockPoint = new THREE.Vector3();
                if (preset.y !== 0) {
                    mockPoint.set(0, preset.y, 0);
                } else {
                    // For color presets, mock point is on the ring at the correct angle
                    const angle = (preset.hue - 0.5) * (2 * Math.PI);
                    mockPoint.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                }
                const info = getSpectralInfo(mockPoint);
                updateInspector(info);
                updateSelectionIndicator(mockPoint);
            });
        });

        document.getElementById('resetRotation').addEventListener('click', () => {
            camera.position.set(4, 3, 4);
            controls.target.set(0, 0, 0);
            controls.update();
            isRotating = true;
            biconeGroup.rotation.y = 0;
            rotationToggle.textContent = 'Pause Rotation';
            selectionIndicator.visible = false;
            document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        function animate() {
            requestAnimationFrame(animate);
            material.uniforms.time.value = performance.now() * 0.001;

            if (isRotating) {
                biconeGroup.rotation.y += 0.005;
            }

            performRaycast();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
